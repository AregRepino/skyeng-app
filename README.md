## Задание

Необходимо реализовать REST API, который позволяет отслеживать почтовые отправления.
В системе должны регистрировать почтовые отправления — письма, посылки — их передвижение между почтовыми отделениями, а также должна быть реализована возможность получения информации и всей истории передвижения конкретного почтового отправления.
Операции, которые должны быть реализованы:
- регистрации почтового отправления,
- его прибытие в промежуточное почтовое отделение,
- его убытие из почтового отделения,
- его получение адресатом,
- просмотр статуса и полной истории движения почтового отправления.

Почтовое отправление определяется следующими свойствами:
- идентификатор,
- тип (письмо, посылка, бандероль, открытка),
- индекс получателя,
- адрес получателя,
- имя получателя.

Почтовое отделение характеризуется следующими свойствами :
- индекс,
- название,
- адрес получателя.

Сервис может быть реализован в видео JSON либо XML-сервиса на выбор. Сервис может быть реализован при помощи стека Java EE или Spring.

СУБД для хранения данных может использоваться любая.

Работа с данными должна быть выполнена с помощью ORM, библиотека может использоваться любая.

Приложение должно быть собрано при помощи Maven или Gradle.

Результатом работы должен быть war или ear-архив, который может быть размещен на сервер приложений. Для отладки и демонстрации может использоваться любой сервер приложений.

К приложению должно прилагаться описание его API — структура запросов и ответов, список допустимых операций, можно это реализовать в виде проекта SoapUI.

Код должен быть покрыт тестами минимум на 70% (приложить скрин покрытия)


## API


Parcels
- `GET`     /parcels/{id} - получение посылки по id
- `POST`    /parcels - создание посылки

Post Office:
- `GET`     /post-offices/{id} - получение почтового отделения по id
- `POST`    /post-offices - создание почтового отделения

Tracking
- `GET`     /trackings/{id} - получение трэкинга по id
- `POST`    /trackings - создание трэкинга
- `PUT`    /trackings/{id} - обновление трэкинга
- `GET`    /trackings?parcelId= - получение истории трэкинга по номеру посылки

`Tracking_API.postman_collection.json` - Postman коллекция для API запросов к серверу.

Вышеуказанные API позволяет выполнять операции из задания.

- регистрации почтового отправления -> `POST /parcels`
- его прибытие в промежуточное почтовое отделение -> `POST /trackings`
- его убытие из почтового отделения -> `PUT /trackings/{id}`
- его получение адресатом -> `PUT /trackings/{id}`
- просмотр статуса и полной истории движения почтового отправления -> `GET /trackings?parcelId=`

## База данных

Используется `H2 InMemory DB` для простоты запуска и тестирования.


### Тесты

Код покрыт юнит тестами. 



### Инструкция

Собрать проект
```
./gradlew build 
```

В папке `builds/libs` сгенерируются архивы: `.jar` и `.war`


Собрать проект `.war`
```
./gradlew war 
```

В папке `builds/libs` сгенерируется архив `.war`


Отчет по покрытию тестами. 
```
./gradlew jacocoTestReport
```
Из тест отчета исключены классы, которые имеют автогенерируемый код от MapStruct и Lombok.

![test-coverage-report](./test-coverage-report.png)



Запустить сервис
```
./gradlew bootRun - 
```

Запустить тесты

``` 
 ./gradlew test
```


Запустить докер

```
docker build -t api .

docker run -p 9009:9009 api
```

## Ссылки

- https://bootify.io/spring-data/mapstruct-with-maven-and-lombok.html



1) Пропертисы не должны хранить персональные данные различных подключений и настроек конфигурации.
2) При авторизации "in memory" данные пользователя лучше выносить из
   кода, чтобы была возможность их изменения без повторной сборки
   приложения.
JWT - 
3) В контроллерах не должно быть никакой бизнес-логики: ни мапперов, ни
   проверок, ни присваиваний.
DTO - data **transfer** object - живет на уровне Контроллера. 
Сервис и Репозиторий работают с Entity
Такой способ разделение ответсвенности
4) Неправильно делать одну DTO на все эндпоинты. На каждый эндпоинт
   должны быть реализованы 2 DTO: на request и response. Это слегка нарушит
   принципы SOLID, однако позволит реализовывать масштабируемые проекты,
   где при необходимости внесения правок в DTO для одного эндпоинта не
   придется искать в коде, где эта DTO может использоваться и что-то
   сломать.
У нас 3 DTO на 3 операции создание и 2 типа обновления contacts и details

5) Сервис должен имплементироваться от интерфейса. В данном случае этого
   не происходит.
YAGNI - если надо допишим и поменяем
6) 
7) Отсутствуют SQL запросы в репозиториях, хотя в резюме указан опыт
   работы с SQL, не увидели такого опыта.
